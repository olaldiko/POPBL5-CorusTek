-- FUNCION QUE DEVUELVE EL ID DEL TIPO DE RECURSO, DANDOLE EL ID DEL RECURSO.
CREATE OR REPLACE FUNCTION F_GET_TYPE_RESOURCE(id INTEGER)
RETURNS INTEGER AS $$
	DECLARE
		type_id INTEGER := -1;
	BEGIN
		SELECT E.TIPORECURSOID INTO type_id FROM ESTACIONES E
		JOIN RECURSOS R ON R.ESTACIONID = E.ESTACIONID
		WHERE R.RECURSOID = id;
		RETURN type_id;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN -2;
	END
$$ LANGUAGE plpgsql;
-- FUNCION QUE DEVUELVE EL ID DEL TIPO DE RECURSO, DANDOLE EL ID DE ESTACION.
CREATE OR REPLACE FUNCTION F_GET_TYPE_STATION(id INTEGER)
RETURNS INTEGER AS $$
	DECLARE
		type_id INTEGER := -1;
	BEGIN
		SELECT E.TIPORECURSOID INTO type_id FROM ESTACIONES E
		WHERE E.ESTACIONID = id;
		RETURN type_id;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN -2;
	END
$$ LANGUAGE plpgsql;
-- FUNCION QUE DEVUELVE LA UBICACIÓN MÁS RECIENTE DE UN RECURSO.
CREATE OR REPLACE FUNCTION F_GET_LOCATION_RESOURCE(id INTEGER)
RETURNS RECORD AS $$
	DECLARE
		x RECORD;
	BEGIN
		SELECT H.UBICACIONLAT AS LAT, H.UBICACIONLNG AS LNG, H.FECHA AS FECHA INTO x
		FROM HIST_UBICACION H
		WHERE H.RECURSOID = id AND H.FECHA = MAX(H.FECHA);
		RETURN x;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN NULL;
	END
$$ LANGUAGE plpgsql;
-- FUNCION QUE DEVUELVE LA UBICACIÓN DE UNA ESTACIÓN.
CREATE OR REPLACE FUNCTION F_GET_LOCATION_STATION(id INTEGER)
RETURNS RECORD AS $$
	DECLARE
		x RECORD;
	BEGIN
		SELECT E.UBICACIONLAT AS LAT, E.UBICACIONLNG AS LNG INTO x
		FROM ESTACIONES E
		WHERE E.ESTACIONID = id;
		RETURN x;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN NULL;
	END
$$ LANGUAGE plpgsql;
-- FUNCION QUE DEVUELVE EL NOMBRE DE LA ESTACIÓN.
CREATE OR REPLACE FUNCTION F_GET_NAME_STATION(id INTEGER)
RETURNS VARCHAR AS $$
	DECLARE
		name VARCHAR := 'N/A';
	BEGIN
		SELECT E.NOMBREESTACION AS name
		FROM ESTACIONES E
		WHERE E.ESTACIONID = id;
		RETURN name;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN NULL;
	END
$$ LANGUAGE plpgsql;
-- FUNCION QUE DEVUELVE LA GRAVEDAD DE UNA INCIDENCIA.
CREATE OR REPLACE FUNCTION F_GET_SEVERITY_INCIDENT(id INTEGER)
RETURNS INTEGER AS $$
	DECLARE
		severity INTEGER := -1;
	BEGIN
		SELECT (EXTRACT(MINUTE FROM (NOW()::TIMESTAMP - I.FECHANOTIFICACION)) * I.GRAVEDAD) INTO severity
		FROM HIST_INCIDENCIAS I;
		RETURN severity;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN -2;
	END
$$ LANGUAGE plpgsql;
-- FUNCION QUE DEVUELVE EL USUARIO POR SU DNI.
CREATE OR REPLACE FUNCTION F_GET_USER_ID(dni VARCHAR)
RETURNS INTEGER AS $$
	DECLARE
		id INTEGER := -1;
	BEGIN
		SELECT U.USUARIOID INTO id
		FROM USUARIOS U
		WHERE U.DNI = dni;
		RETURN id;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN -2;
	END
$$ LANGUAGE plpgsql;
-- FUNCION QUE INSERTA UN USUARIO SIN CRYPT.
CREATE OR REPLACE FUNCTION F_INSERT_USER(name VARCHAR, ape VARCHAR, dir VARCHAR, tlf VARCHAR, obs VARCHAR, dni VARCHAR, v_user VARCHAR, pass TEXT)
RETURNS INTEGER AS $$
	DECLARE
		cod INTEGER := -1;
	BEGIN
		INSERT INTO USUARIOS (NOMBRE, APELLIDO, DIRECCION, TELEFONO, NOTAS, DNI, USERNAME, PASSWORD)
		VALUES (name, ape, dir, tlf, obs, dni, v_user, pass)
		RETURNING USUARIOID INTO cod;
		RETURN cod;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN -2;
	END
$$ LANGUAGE plpgsql;
-- FUNCION QUE ACTUALIZA UN USUARIO.
CREATE OR REPLACE FUNCTION F_UPDATE_USER(id INTEGER, name VARCHAR, ape VARCHAR, dir VARCHAR, tlf VARCHAR, obs VARCHAR, dni VARCHAR, v_user VARCHAR, pass TEXT)
RETURNS INTEGER AS $$
	DECLARE
		cod INTEGER := -1;
		i INTEGER := 0;
	BEGIN
		IF (name != NULL) THEN
			UPDATE USUARIOS
			SET NOMBRE = name
			WHERE USUARIOID = id;
			i = i + 1;
		END IF;
		IF (ape != NULL) THEN
			UPDATE USUARIOS
			SET APELLIDO = ape
			WHERE USUARIOID = id;
			i = i + 1;
		END IF;
		IF (dir != NULL) THEN
			UPDATE USUARIOS
			SET DIRECCION = dir
			WHERE USUARIOID = id;
			i = i + 1;
		END IF;
		IF (tlf != NULL) THEN
			UPDATE USUARIOS
			SET TELEFONO = tlf
			WHERE USUARIOID = id;
			i = i + 1;
		END IF;
		IF (obs != NULL) THEN
			UPDATE USUARIOS
			SET NOTAS = obs
			WHERE USUARIOID = id;
			i = i + 1;
		END IF;
		IF (dni != NULL) THEN
			UPDATE USUARIOS
			SET DNI = dni
			WHERE USUARIOID = id;
			i = i + 1;
		END IF;
		IF (v_user != NULL) THEN
			UPDATE USUARIOS
			SET USERNAME = v_user
			WHERE USUARIOID = id;
			i = i + 1;
		END IF;
		IF (pass != NULL) THEN
			UPDATE USUARIOS
			SET PASSWORD = pass
			WHERE USUARIOID = id;
			i = i + 1;
		END IF;
		cod := i;
		RETURN cod;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN -2;
	END
$$ LANGUAGE plpgsql;
-- FUNCION QUE AUTENTIFICA AL USUARIO POR USERNAME.
CREATE OR REPLACE FUNCTION F_CHECK_USER_USERNAME(v_user VARCHAR, pass TEXT)
RETURNS INTEGER AS $$
	DECLARE
		i_user VARCHAR;
	BEGIN
		SELECT USERNAME INTO i_user
		FROM USUARIOS
		WHERE USERNAME = v_user AND PASSWORD = pass;
		IF (i_user == NULL) THEN
			RETURN 1;
		ELSE
			RETURN 0;
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN -2;
	END
$$ LANGUAGE plpgsql;
-- FUNCION QUE BORRA AL USUARIO POR USERNAME.
CREATE OR REPLACE FUNCTION F_DELETE_USER_USERNAME(v_user VARCHAR)
RETURNS INTEGER AS $$
	DECLARE
		id INTEGER := -1;
	BEGIN
		DELETE FROM USUARIOS WHERE USERNAME = v_user
		RETURNING USUARIOID INTO id;
		RETURN id;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN -2;
	END
$$ LANGUAGE plpgsql;
